        -:    0:Source:listechainee.c
        -:    0:Graph:listechainee.gcno
        -:    0:Data:listechainee.gcda
        -:    0:Runs:1
        -:    0:Programs:1
        -:    1:#include <stdlib.h>
        -:    2:#include <string.h>
        -:    3:#include <stdio.h>
        -:    4:#include <ctype.h>
        -:    5:#include "listechainee.h"
        -:    6:#include "main.h"
        -:    7:
        8:    8:void initialize_list(LinkedList *word_list) {
        8:    9:    word_list->head = NULL;
        8:   10:    word_list->tail = NULL;
        8:   11:    word_list->word_count = 0;
        8:   12:}
        -:   13:
        -:   14:
        2:   15:void print_empty_list_message(const LinkedList *word_list) {
        2:   16:    if (word_list->word_count == 0) {
    #####:   17:        printf("La liste de mots est vide\n");
    #####:   18:        return;
        -:   19:    }
        2:   20:}
        -:   21:
      792:   22:void validate_letters_in_word(char char_in_word) {
        -:   23:
      792:   24:    if (!isalpha(char_in_word) || !isupper(char_in_word)) {
    #####:   25:        fprintf(stderr, "Erreur, tous les mots du fichiers doivent "
        -:   26:                "être des lettres majuscules sans caractères accentués\n");
    #####:   27:        exit(EXIT_FAILURE);
        -:   28:    }
      792:   29:}
        -:   30:
        -:   31:
        2:   32:void delete_duplicate(LinkedList *word_list) {
        2:   33:    print_empty_list_message(word_list);
        2:   34:    Node *current = word_list->head;
      127:   35:    while (current != NULL && current->next != NULL) {
      125:   36:        if (strcmp(current->word, current->next->word) == 0) {
        -:   37:            
      117:   38:            Node *duplicate = current->next;
      117:   39:            current->next = duplicate->next;
      117:   40:            word_list->word_count--;
        -:   41:            
      117:   42:            free(duplicate->word);
      117:   43:            free(duplicate);
        -:   44:
      117:   45:            if (current->next == NULL) {
        1:   46:                word_list->tail = current;
        1:   47:            }
      117:   48:        } else {
        8:   49:            current = current->next;
        -:   50:        }
        -:   51:    }
        2:   52:}
        -:   53:
        4:   54:void free_word_list(LinkedList *word_list) {
        4:   55:    Node *current = word_list->head;
        -:   56:    Node *next;
        -:   57:
       22:   58:    while (current != NULL) {
       18:   59:        next = current->next;
       18:   60:        free(current->word); 
       18:   61:        free(current);
       18:   62:        current = next;
       18:   63:        word_list->word_count--;
        -:   64:    }
        4:   65:    word_list->head = NULL;
        4:   66:}
        -:   67:
    #####:   68:void print_list(const LinkedList *word_list) {
    #####:   69:    print_empty_list_message(word_list);
    #####:   70:    Node *current = word_list->head;;
        -:   71:
    #####:   72:    while (current != NULL) {
    #####:   73:        printf("%s\n", current->word);
    #####:   74:        current = current->next;
        -:   75:    }
    #####:   76:}
        -:   77:
      146:   78:struct Node* create_node(const char *new_word) {
      146:   79:    struct Node* new_node = (struct Node*)malloc(sizeof(Node));
        -:   80:    
      146:   81:    if (new_node == NULL) {
    #####:   82:        perror("Erreur d'allocation de mémoire pour le nœud");
    #####:   83:        exit(EXIT_FAILURE);
        -:   84:    }
        -:   85:
      146:   86:    new_node->word = (char*)malloc(strlen(new_word) + 1);
        -:   87:    
      146:   88:    if (new_node->word == NULL) {
    #####:   89:        perror("Erreur d'allocation de mémoire pour le mot");
    #####:   90:        free(new_node);
    #####:   91:        exit(EXIT_FAILURE);
        -:   92:    }
        -:   93:
      146:   94:    strcpy(new_node->word, new_word);
      146:   95:    new_node->next = NULL;
        -:   96:
      146:   97:    return new_node;
        -:   98:}
        -:   99:
        -:  100:
        7:  101:void insert_into_empty_list(LinkedList *word_list, Node *new_node) {
        7:  102:    word_list->head = new_node;
        7:  103:    word_list->tail = new_node;
        7:  104:    word_list->word_count++;
        7:  105:}
        -:  106:
      145:  107:void insert_in_order(LinkedList *word_list, const char *new_word) {
      145:  108:    Node *new_node = create_node(new_word);
        -:  109:
      145:  110:    if (word_list->word_count == 0) {
        6:  111:        insert_into_empty_list(word_list, new_node);
        6:  112:        return;
        -:  113:    }
      139:  114:    Node *current = word_list->head;
      139:  115:    Node *previous = NULL;
        -:  116:
     4557:  117:    while (current != NULL && strcmp(current->word, new_node->word) <= 0) {
     4418:  118:        previous = current;
     4418:  119:        current = current->next;
        -:  120:    }
        -:  121:
      139:  122:    if (previous == NULL) {
        3:  123:        new_node->next = word_list->head;
        3:  124:        word_list->head = new_node;
        3:  125:    } else {
      136:  126:        previous->next = new_node;
      136:  127:        new_node->next = current;
        -:  128:
      136:  129:        if (current == NULL) {
       38:  130:            word_list->tail = new_node;
       38:  131:        }
        -:  132:    }
        -:  133:
      139:  134:    word_list->word_count++;
      145:  135:}
        -:  136:
        -:  137:
        1:  138:void insert_word_from_file(FILE *file, LinkedList *word_list) {
        -:  139:    char line[MAX_CHAR + 1];
        -:  140:    char line_copy[MAX_CHAR + 1];
       25:  141:    while (fgets(line, sizeof(line),file)) {
       24:  142:        strcpy(line_copy, line);
       24:  143:        char *word = strtok(line_copy, " \n");
      144:  144:        while (word != NULL) {
      912:  145:            for (int i = 0; word[i] != '\0'; i++) {
      792:  146:                validate_letters_in_word(word[i]);
      792:  147:            }
      120:  148:            insert_in_order(word_list, word);
      120:  149:            word = strtok(NULL, " \n");
        -:  150:        }
        -:  151:    }
        1:  152:}
        -:  153:
        -:  154:
