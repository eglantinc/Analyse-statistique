        -:    0:Source:listechainee.c
        -:    0:Graph:listechainee.gcno
        -:    0:Data:listechainee.gcda
        -:    0:Runs:1
        -:    0:Programs:1
        -:    1:#include <stdlib.h>
        -:    2:#include <string.h>
        -:    3:#include <stdio.h>
        -:    4:#include "listechainee.h"
        -:    5:
    #####:    6:void initialize_list(LinkedList *word_list) {
    #####:    7:    word_list->head = NULL;
    #####:    8:    word_list->tail = NULL;
    #####:    9:    word_list->word_count = 0;
    #####:   10:}
        -:   11:
        -:   12:
    #####:   13:void print_empty_list_message(const LinkedList *word_list) {
    #####:   14:    if (word_list->word_count == 0) {
    #####:   15:        printf("La liste de mots est vide\n");
    #####:   16:        return;
        -:   17:    }
    #####:   18:}
        -:   19:
    #####:   20:void delete_duplicate(LinkedList *word_list) {
    #####:   21:    print_empty_list_message(word_list);
    #####:   22:    Node *current = word_list->head;
    #####:   23:    while (current != NULL && current->next != NULL) {
    #####:   24:        if (strcmp(current->word, current->next->word) == 0) {
        -:   25:            
    #####:   26:            Node *duplicate = current->next;
    #####:   27:            current->next = duplicate->next;
    #####:   28:            word_list->word_count--;
        -:   29:            
    #####:   30:            free(duplicate->word);
    #####:   31:            free(duplicate);
        -:   32:
    #####:   33:            if (current->next == NULL) {
    #####:   34:                word_list->tail = current;
    #####:   35:            }
    #####:   36:        } else {
    #####:   37:            current = current->next;
        -:   38:        }
        -:   39:    }
    #####:   40:}
        -:   41:
    #####:   42:void free_word_list(LinkedList *word_list) {
    #####:   43:    Node *current = word_list->head;
        -:   44:    Node *next;
        -:   45:
    #####:   46:    while (current != NULL) {
    #####:   47:        next = current->next;
    #####:   48:        free(current->word); 
    #####:   49:        free(current);
    #####:   50:        current = next;
    #####:   51:        word_list->word_count--;
        -:   52:    }
    #####:   53:    word_list->head = NULL;
    #####:   54:}
        -:   55:
    #####:   56:void print_list(const LinkedList *word_list) {
    #####:   57:    print_empty_list_message(word_list);
    #####:   58:    Node *current = word_list->head;;
        -:   59:
    #####:   60:    while (current != NULL) {
    #####:   61:        printf("%s\n", current->word);
    #####:   62:        current = current->next;
        -:   63:    }
    #####:   64:}
        -:   65:
    #####:   66:struct Node* create_node(const char *new_word) {
    #####:   67:    struct Node* new_node = (struct Node*)malloc(sizeof(Node));
        -:   68:    
    #####:   69:    if (new_node == NULL) {
    #####:   70:        perror("Erreur d'allocation de mémoire pour le nœud");
    #####:   71:        exit(EXIT_FAILURE);
        -:   72:    }
        -:   73:
    #####:   74:    new_node->word = (char*)malloc(strlen(new_word) + 1);
        -:   75:    
    #####:   76:    if (new_node->word == NULL) {
    #####:   77:        perror("Erreur d'allocation de mémoire pour le mot");
    #####:   78:        free(new_node);
    #####:   79:        exit(EXIT_FAILURE);
        -:   80:    }
        -:   81:
    #####:   82:    strcpy(new_node->word, new_word);
    #####:   83:    new_node->next = NULL;
        -:   84:
    #####:   85:    return new_node;
        -:   86:}
        -:   87:
        -:   88:
    #####:   89:void insert_into_empty_list(LinkedList *word_list, Node *new_node) {
    #####:   90:    word_list->head = new_node;
    #####:   91:    word_list->tail = new_node;
    #####:   92:    word_list->word_count++;
    #####:   93:}
        -:   94:
    #####:   95:void insert_in_order(LinkedList *word_list, const char *new_word) {
    #####:   96:    Node *new_node = create_node(new_word);
        -:   97:
    #####:   98:    if (word_list->word_count == 0) {
    #####:   99:        insert_into_empty_list(word_list, new_node);
    #####:  100:        return;
        -:  101:    }
    #####:  102:    Node *current = word_list->head;
    #####:  103:    Node *previous = NULL;
        -:  104:
    #####:  105:    while (current != NULL && strcmp(current->word, new_node->word) <= 0) {
    #####:  106:        previous = current;
    #####:  107:        current = current->next;
        -:  108:    }
        -:  109:
    #####:  110:    if (previous == NULL) {
    #####:  111:        new_node->next = word_list->head;
    #####:  112:        word_list->head = new_node;
    #####:  113:    } else {
    #####:  114:        previous->next = new_node;
    #####:  115:        new_node->next = current;
        -:  116:
    #####:  117:        if (current == NULL) {
    #####:  118:            word_list->tail = new_node;
    #####:  119:        }
        -:  120:    }
        -:  121:
    #####:  122:    word_list->word_count++;
    #####:  123:}
        -:  124:
        -:  125:
